\subsection{Protocol Execution Model}
\label{subsec:protocol-execution-model}

Our model follows Canetti's formulation of ``real world'' notion of protocol execution \cite{JC:Canetti00,EPRINT:Canetti00} for multi-party protocols.
%
To specify the ``resources'' that may be available to the instances running protocol---e.g., the diffuse channel---we will follow the approach of describing them as ideal functionalities in the terminology of \cite{EPRINT:Canetti00}.\footnote{Note that these notions are used for model description only, our security proof is property-based.}

The protocol execution proceeds in ``rounds''.
%
Parties are always aware of the current round (i.e., synchronous processors); this is captured by a global clock \funcClock \cite{TCC:KMTZ13}.
%
Inputs are provided by an environment program \Z to parties that execute the protocol $\Pi$.
%
The adversary \adv is a single entity that takes control of corrupted parties, and is both ``adaptive'' (i.e., \adv can take control of parties on the fly) and ``rushing'' (\adv is allowed to observe honest parties' actions before deciding her reaction).
%
The hash function $H(\cdot)$ is modeled as a random oracle \funcRO and abstracts parties attempting to solve ``proof-of-work'' \cite{C:DwoNao92}.
%
Following the convention that different types of messages are diffused by their own network, we consider two diffusion functionalities --- one for general messages (\funcDiffuse) and another for transactions (see below).
%
For all messages except transactions, the communication is bounded-delay.
%
I.e., there is an upper bound \delay (measured in number of rounds) and the adversary may delay the delivery of messages for up to \delay rounds.

\paragraph{Transaction diffusion model.}
%
The environment program \Z generates new transactions which are disseminated through the diffusion functionality.
%
We consider two types of transaction diffusion functionalities --- $\funcDiffuse^{\mathsf{tx}, \mathsf{async}}$ and $\funcDiffuse^{\mathsf{tx}, \txDelay}$.
%
The first one captures the asynchronous transaction diffusion, i.e., in $\funcDiffuse^{\mathsf{tx}, \mathsf{async}}$ the adversary can deliver a transaction \tx at any time (after \tx is generated by \Z).
%
The only restriction is that $\funcDiffuse^{\mathsf{tx}, \mathsf{async}}$ should send all transactions to all honest parties eventually.
%
The second one captures a \txDelay-disseminated transaction diffusion network.
%
Specifically, in $\funcDiffuse^{\mathsf{tx}, \txDelay}$ the adversary is forced to deliver a transaction to all the honest parties within \txDelay rounds after it is learnt by at least one honest participant.
%
Considering the physical limits on transaction throughput, we assume that the total number of transactions will be a polynomial function of the running time of protocol execution.

\paragraph{Dynamic participation.}
%
In order to describe the protocol execution in a more realistic fashion, following the treatment in~\cite{CCS:BGKRZ18}, we classify protocol participants into different types (detailed in \cref{table:dynamic-participation}).
%
Especially, \emph{alert} parties---the core set of parties to carry out the protocol---are those who have access to all the resources (random oracle, network, clock) and are synchronized with each other.
%
We also put some restriction on the environment's power to fluctuate the number of \emph{alert} parties \cite{C:GarKiaLeo17,EPRINT:GarKiaLeo20}; i.e., for any window of fixed length, the increase/decrease on the number of alert parties is bounded (details see \cref{def:respecting-env} in \cref{sec:preliminaries-contd}).

\paragraph{State machine replication.}
%
State machine replication \cite{CSUR:Schneider90} is a problem that asks a set of parties accepting input logs to maintain a public data structure that serializes the logs.
%
This public data structure is called \emph{ledger} in the context of ledger consensus (cf. \cite{EC:GarKiaLeo15,RSA:GarKia20}).
%
Conventionally, a public ledger should satisfy two properties (we adopt \ledger as the settled part of the ledger in party's view, and $\widetilde{\ledger}$ the whole ledger held by the party).
%
\begin{enumerate}[label=\FlatSteel, leftmargin=*, noitemsep]
    \item \textbf{Consistency}: For any two honest parties \party, $\party'$ reporting \ledger, $\ledger'$ at rounds $r \le r'$, respectively, it holds that \ledger is a prefix of $\widetilde{\ledger'}$.
    
    \item \textbf{Liveness}: (parameterized by $u \in \mathbb{N}$, the ``wait time'' parameter): If a transaction \tx is provided to all honest parties for $u$ consecutive rounds, then it holds that for any player \party, \tx will be in \ledger.
\end{enumerate}
